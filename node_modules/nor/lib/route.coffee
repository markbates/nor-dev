sys = require 'sys'
lingo = require 'lingo'

class Nor.Route

  constructor: (@pattern, @method = 'get', @options = {}) ->
    @patternResults = {}
    @patternNames = []
    @controller_name = null
    @action_name = null
    @processPattern()
    @processMapping()
    
  processPattern: ->
    unless @pattern instanceof RegExp
      while match = (/(\:[^\/\?]+)/g).exec(@pattern)
        @patternNames.push match[0]
        @pattern = @pattern.replace(match[0], "([^\\/\?]+)")

      @pattern = new RegExp("#{@pattern}$", 'g')

  processMapping: ->
    return if @options['endpoint']
    @processTo()
  
  processTo: ->
    to = @options['to']
    unless to or @options['endpoint']
      throw new Error("Route: #{@pattern} does not define a 'to' mapping or an 'endpoint' function!")
    mappings = to.split('#')
    @controller_name = mappings[0]
    @action_name = mappings[1]
    @controller = "#{@controller_name} controller"
    @controller = lingo.camelcase(@controller, true)
    @controller_file_name = "#{@controller_name}_controller"
    @options['endpoint'] = (env) ->
      con = require("#{Nor.Application.root}/app/controllers/#{@controller_file_name}").controller
      con = new con(env)
      if con[@action_name]
        con[@action_name].apply(con)
      else
        Nor.Middleware.Router.routeNotFound(env)

  matches: (url) ->
    matches = [] 
    while match = (@pattern).exec(url) 
      matches.push match

    matches = matches[0]

    return false unless matches?
    
    results = matches[1..matches.length - 1]
    for name, index in @patternNames
      @patternResults[name.slice(1,name.length)] = results[index]
      
    return true

  exec: (env) ->
    env.controller_name = @controller_name
    env.action_name = @action_name
    env.controller_file_name = @controller_file_name
    env.route = @
    for key, val of @patternResults
      env.params[key] = val
    @options['endpoint'].call(@, env)